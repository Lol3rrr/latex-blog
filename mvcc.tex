\documentclass[a4paper, 11pt]{article}

\title{My Spin on MVCC for a toy database}
\date{October 2023}

\begin{document}
\section{Introduction}
This is just a small idea I had while thinking about how I could implement MVCC for transactions in my custom
toy database.

\section{Properties}
These are the core properties that I was interested in, from a standard database point of view
\begin{enumerate}
\item Repetable Reads
\item (Snapshot isolation)
\item (Serializable)
\end{enumerate} \\
However there were some more interesting aspects from a technical point of view as well
\begin{enumerate}
\item Transactions should be as independent as possible
\item Transactiosn should not block each other
\item High scalability
\end{enumerate}

\section{Idea}
\begin{enumerate}
\item $C \subseteq \mathbb{N}$: The Committed Transactions
\item $B \subseteq \mathbb{N}$: The Aborted Transactions
\item $C \cap B = \emptyset$
\item $WT \in \mathbb{N}$
\end{enumerate}

\subsection{Starting a Transaction}
Get a Snapshot of $C_t = C$ and $B_t = B$, these won't change for the entire duration of the Transaction and are what
will ensure the "Repetable Read" property.

\subsection{Performing a Read}
When performing a Read, you search for the most recent row entry where the commit transaction id is the highest transaction id
that is in $C$, so $tx_row \in C$

\subsection{Performing a Write}
For the first write, you obtain a $WT_t = WT + 1$ and update $WT = WT + 1$. \\
Then when performing any write, you simply write the row entry the transaction id set to $WT_t$

\subsection{Committing}
% TODO

\subsection{Aborting}
% TODO

\end{document}
